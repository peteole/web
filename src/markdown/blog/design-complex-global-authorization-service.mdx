---
path: '/design-complex-global-authorization-service/'

title: >
  Design a complex authorization service with Ory Keto

seo:
  description: >
    Design a complex authorization service with billions of relations, groups and requests.
    This article will demonstrate Ory Keto, the open source implementation of Google Zanzibar
    access control.
  title: >
    Global authorization service architecture

publishedAt: '2022-03-28'
author: vinckr
overline: >
  Authorization architecture

category: Article

teaser: >
  Design a complex authorization service with billions of relations, groups and requests.
  
tags:
  - Open Source
  - Access Control
  - Authorization
  - Architecture
---


This article is based on the "Design Complex Authorization with Ory Keto" talk by @zepatrik.
You can watch the talk here:

https://www.youtube.com/watch?v=lGRMYkQrNb0

## Introduction

Ory Keto is a service that you can use to implement authorization in any application. Authorization means it can answers the questions "Is this user allowed to do this?".
Ory Keto is inspired by the paper that Google wrote about their acccess control system called Zanzibar and draws a lot of the theoretical background from the implementation that Google chose. 
In my last post I wrote about the theoretical background of the Zanzibar papers and the challenges that such a global access control system with billions of users faces. 
In this post I will give a highlevel overviwe on how Keto works and then jummp into some concrete examples.

So what does it mean that Ory Keto is based on the zanzibar paper? 
The core principle of the google acccess zanzibar  is that of a graph of relations, and I will come in a moment to why this graph is great. 
< show image here>

## Graph of relations

The basic data structure is relation tuples. There are two types of relation tuples
-  Example here: "object0#access@user0"
>a relation tuple that describes a relation between an object and a subject which sounds pretty generic and also is pretty generic because objects, relations and subjects are just strings
What Ory Keto does in with this type of relation tuple, is it will just give you all the connections between those relations

- second type: subject sets: "object1#access@(object0#acccess)"
>(everyone who has access to object zero -so this part is the subject set - so everyone who has access to object zero also has access to object one)
subject sets are a way to indirect and define relations based on other relations.

Together with the first type of relation tuples this allows to define permissions, so for example you can say if you have this relation or that relation you have access. 

So why a graph of relations?

the basic idea behind this is that these relations result in a graph of relations. This graph is just a very standard directed graph and we can apply standard graph algorithms to this graph and in such a case or such an algorithm would be to actually do a permission check
So in practice that is done by having a reachability problem on the graph, so if an object is reachable through a specific relation from a subject it's considered that this is a true request. 
So the Check API will basically allow the request to go through. And if there is no connection then it will stay false.
And thats on a basic level how Ory Keto works.

so you can also build representations of this graph of relations and do audits on it, and so have a very fine grained control over who can access what and so on.

- very basic idea behind the Zanzibar paper or the graph based permissions

(screens of how the relations work out when you start to resolve them and all of these indirections so you can do audits on basically this graph structure)

- namespaces: 
Namespaces are a way to organize objects to prevent naming conflicts - what means you can distinguish two obejcts that have the same id althought they should neer have the same ID. They can also be later on used for some extra relational features, so for example instead of adding a relation namespaces can be used to exclude froma. relation. 

## Lets hack


gh repo clone zepatrik/ory-summit21-talk
cd ory-summit21-talk
npm i
npm start

Our example starts a basic NodeJS server:
```
https://raw.githubusercontent.com/zepatrik/ory-summit21-talk/main/examples/server.ts
```

The server listen to the port set, some course headers, and here handleGet and handlePost. A simple cloud storage, key is the filename, and value is the content.

In this presentation we have a built-in client - so we can launch that client as well.
Navigate to http://localhost:9000/ and press `c` to launch the client overlay. ignore the username field for now.

add example.txt in the filename and foo in the contents and press POST
You will get this output
```
fetch('http://localhost:7000/example.txt', {
      method: 'POST',
      headers: {
        authorization: ''
      },
      body: content
    })
``` 

POST writes the file so it reads the body and writes to the file.
The client also has a handleGet fuction which reads a file and serves it, if possible. handleGet returns an error if it can't find it, can't open it for whatever reason.

See the full code for this basic client:
```
https://raw.githubusercontent.com/zepatrik/ory-summit21-talk/main/examples/handlers-0.ts
```

### Create relations

We want to track the ownership of these files now.
We want to then later add permissions so the owners can read, can modify, can update a file and can change the sharing permissions and more.
To achieve this we add the following to our handler:
```
https://raw.githubusercontent.com/zepatrik/ory-summit21-talk/main/examples/handlers-1.ts
(add diff here) (or break down below)
```
Some imports and helper function 
This is the code to create relation tuples:

```jsx https://raw.githubusercontent.com/zepatrik/ory-summit21-talk/main/examples/handlers-1.ts
const addOwnershipRelation = (filePath: string, username: string) => {
  const relationTuple = new acl.RelationTuple()
  relationTuple.setNamespace('files')
  relationTuple.setObject(filePath)
  relationTuple.setRelation('owner')

  const sub = new acl.Subject()
  sub.setId(username)
  relationTuple.setSubject(sub)

  const tupleDelta = new write.RelationTupleDelta()
  tupleDelta.setAction(write.RelationTupleDelta.Action.INSERT)
  tupleDelta.setRelationTuple(relationTuple)

  const writeRequest = new write.TransactRelationTuplesRequest()
  writeRequest.addRelationTupleDeltas(tupleDelta)

  return new Promise<void>((resolve, reject) => {
    writeClient.transactRelationTuples(writeRequest, (error) => {
      if (error) {
        reject(error)
      } else {
        resolve()
      }
    })
  })
}
```

Now we use the `files` namespaces and we set the path of the file as the object.
There is also an owner relationship `relationTuple.setRelation('owner')`
and as the subject we set the username
``` https://raw.githubusercontent.com/zepatrik/ory-summit21-talk/main/examples/handlers-1.ts
  const sub = new acl.Subject()
  sub.setId(username)
  relationTuple.setSubject(sub)
```
And then we do an API call `writeRequest`  to Ory Keto to store this relation.

Integration into the POST handler:

``` https://raw.githubusercontent.com/zepatrik/ory-summit21-talk/main/examples/handlers-1.ts
  // assuming this can only be set by ingress/upstream service/...
  const username = req.headers.authorization
  if (!username) {
    res.statusCode = 403
    res.end('Only for authenticated users.')
    return
  }

  await addOwnershipRelation(filePath, username)
```

Authorization header contains the username - this is just for the purpose of this example! in a real world application you would use a JWT that are set or created in an upstream service (for example Ory Oathkeeper).
So here we get the username and then add the ownership relation between the file and the username.
The idea here is that whenever we create a file, we create this relation in Ory Keto and then later we can request whether a relation exists for permission checks. 

### Check relations

Lets implement a helper function that allows us to do a check whether a user is an owner of a file:

```
show diff to 1
https://raw.githubusercontent.com/zepatrik/ory-summit21-talk/main/examples/handlers-2.ts

,
  check,
  checkService
} from '@ory/keto-grpc-client/ory/keto/acl/v1alpha1'

const checkClient = new checkService.CheckServiceClient(
  '127.0.0.1:4466',
  grpc.credentials.createInsecure()
)

const checkIsOwner = (filePath: string, username: string) => {
  const checkRequest = new check.CheckRequest()
  checkRequest.setNamespace('files')
  checkRequest.setObject(filePath)
  checkRequest.setRelation('owner')

  const sub = new acl.Subject()
  sub.setId(username)
  checkRequest.setSubject(sub)

  return new Promise<boolean>((resolve, reject) => {
    checkClient.check(checkRequest, (error, resp) => {
      if (error) {
        reject(error)
      } else {
        resolve(resp.getAllowed())
      }
    })
  })
}

```

This is the reverse of what we just did: it's looking up whether in the namespace `files` the user is the owner of the file - just as defined in the step before.
In case the user is the owner we serve the file, if not there is an error: "You are not the owner of the file".

Lets test our full setup now.
Launch the client again (localhost:9000 + press c for the overlay)
put in username: example Bob, filename "example.txt", content "dont show anyone"
click POST and you shoudl get success
now lets check if we get access. 

(show screenshot)

Now we leave out the username and see if we can get access again.

One problem with this approach is that we now check directly for ownership. 
You might want to share the file with someone else and you're the owner of the file so you're allowed to share it. Someone else might read it, but they might not be allowed to update it or share it further - or any other combination of those.
In our setup this is not solely reflected by the ownership relation. With this case we limit the flexibility to actually implement the permissions on top of this ownership relation. 

What we should do instead is track the relations as they are, but then actually define the permissions based on the relations. 

Instead of checking whether someone is an owner (`checkIsOwner`) we check for the "read" relation (`checkCanRead`) - this is a new relation that we just introduced:

```diff
+ const checkCanRead = (filePath: string, username: string) => {
  const checkRequest = new check.CheckRequest()
  checkRequest.setNamespace('files')
  checkRequest.setObject(filePath)
+ checkRequest.setRelation('read')
```

This read relation can be defined in a lot of different ways. One very common pattern is that when you can write to a file you usually also can read it.
Another one might be that you get a shared link that allows you to read a file. But you are not the owner of the file and you are not able to edit it. 
That's why this abstraction is important if you are building more complex authorization. 

We also need to create a second tuple and you might notice that this is called "workaround tuple". That's because you currently have to implement a workaround for "subject set rewrites" in Ory Keto. - But it's considered a workaround because we are currently working on subject set rewrites. They will allow to do this without adding tuples. Using subject set rewrites we can define without effort that everyone whose owner also has read access.
The workaround tuple says that you can read the file, the subject set, and if you are owner of the file. 
In this workaround tuple the username does not appear but we define read through ownership - giving everyone who has ownership of a file the `read` permissionl
This gives us flexibility later on, so we will be able to remove that permission, adjust it. We can implement the `write`/`read` relation in the same way.

Check out the full code example on GitHub and the Ory Keto documentation for the next steps.

